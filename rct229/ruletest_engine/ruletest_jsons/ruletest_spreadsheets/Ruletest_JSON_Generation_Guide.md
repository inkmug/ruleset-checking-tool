# Ruletest JSON Generation Guide

## Overview 

This guide will describe the process of generating test JSONs used to test Rules in the Ruleset Checking Tool (RCT). JSON files are generated by spreadsheets developed for each section of the Appendix G's test case descriptions (TCDS) (how should we refer to these?). Each RCT Rule has multiple test case descriptions to exercise different input conditions and tests against expected outcomes. 

These spreadsheets can be found at the `ruletest_engine\ruletest_jsons\ruletest_spreadsheets` directory and generate JSONS using the `ruletest_engine\ruletest_jsons\scripts\excel_to_test_json.py` Python script.

## Spreadsheet Structure

Each ruletest spreadsheet is separated into two notable sections-- keys used to describe JSON paths and the values assigned to them. Both keys and their corresponding JSON path values have some intricacies described here.

### Keys and Values

Each ruletest spreadsheet utilizes keys to describe the JSON path for a given value. This is best described through example. Let's take a look at an example from the envelope tests. Consider the following in the spreadsheet:

| key1 | key2 | key3 | key4 | rule-5-7a |
| ------ | ------ | ------ | ------ | ------ |
| rmr_transformations | user | buildings | is_new | true |

The **four keys** here describe the JSON path. These keys include the following:

- rmr_transformations
- user
- building
- is_new

Their corresponding value for the header `rule-5-7a` is `true`. When ran through the Python script `excel_to_json.py`, the resulting JSON would appear as follows:

``` json
{
    "rule-5-7a": {
            "rmr_transformations": {
                "user": {
                    "buildings": {
                        "is_new": "true"
                        }
                    }
                }
            }
}
```

### The JSON_PATH Keyword

The example above works well when the JSON path one tries to set is not too long. As the RCT schema evolves, fields can become further and further buried down with very long JSON paths. For these cases, it's often helpful to utilize shorthand expressions using the `JSON_PATH` keyword. You can find `JSON_PATH` shorthand in keys throughout the test document. Let's take a look at an example in the envelope test sheet:

Consider the following-- you want to describe a space's floor area in the user RMR inside the `rmr_transformations` section of the test JSON. Using the conventional approach, this would require laying out a very long JSON path:
| key1 | key2 | key3 | key4 | key5 | key6 | key7 |  key8 | rule-5-7a |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| rmr_transformations | user | buildings | building_segments | thermal_blocks | zones | spaces | floor area | 1000 |

Note how the conventional approach requires a great deal of columns to express. By utilizing a `JSON_PATH`, things become substantially tidier. Consider the following:

| key1 | key2 | key3 | key4 | rule-5-7a |
| ------ | ------ | ------ | ------ | ------ |
| rmr_transformations | user | JSON_PATH: spaces | floor_area | 1000 |

The `JSON_PATH` for `spaces` shortens this down substantially. These shorthand enumerations are described in the `\ruletest_engine\ruletest_jsons\scripts\resources\json_pointer_enumerations.json` JSON file. You'll note that the `spaces` path maps to *'buildings/building_segments/thermal_blocks/zones/spaces'*.

### The DICT_LIST Keyword

At times a rule will require multiple of the same element in a test RMR. These require passing a list of dictionaries or a `DICT_LIST` to the Python code instead. This is best described by an example. 

Consider you want to generate the following JSON for transformer test case `rule-15-1a`:

```json
{
    "rule-15-1a": {
        "rmr_transformations": {
            "user": {
                "transformers": [
                    {
                        "name": "Transformer_1"
                    },
                    {
                        "name": "Transformer_2"
                    },
                    {
                        "name": " Transformer_3"
                    }
                ]
            },
        }
    }
}
```

Note how at the how at the `transformers` element there exist three transformers with names `Transformer_1`, `Transformer_2`, and `Transformer_3`. The conventional, 1-to-1 assignments described above would not apply here as the JSON path *rule-15-1a/rmr_transformations/user/transformers/name* requires three separate entrees. This is where we want to use the `DICT_LIST` keyword. 

To generate the above JSON, the key/value description in the test spreadsheet would appear as follows:

| key1 | key2 | key3 | key4 | rule-5-7a |
| ------ | ------ | ------ | ------ | ------ |
| rmr_transformations | user | transformers | DICT_LIST | name:Transformer_1,Transformer_2, Transformer_3 |

The `DICT_LIST` keyword placed as the final key informs the Python code that the value corresponding to this row must be parsed as a list of elements. In this case, a list with `name` as the keyword. The format for the string describing a `DICT_LIST` is *KEY:value_1, value_2, value_3...value_n*





